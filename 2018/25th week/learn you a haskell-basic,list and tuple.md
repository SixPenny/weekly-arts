## Command Collections

- `:?` show help
- `:set prompt "ghci>"`  change the prompt 
- `:set +t` print type infos 
- `:module + Data.Ratio` load a module
- `:module - Data.Ratio` unload the module
- `:m` remove all the modules loaded
- `:unset ` same commands as set
- `:l file-name` load file into ghci


## Start out

- download haskell platform at [downloads](https://downloads.haskell.org/~platform/8.4.3/HaskellPlatform-8.4.3-full-x86_64-setup.exe)

- basic operations
   - `3 + 5` `5 - 6` `3 * 7` `5 / 2` ps: `5/2` result `2.5`
   - comparing `>` `<` `>=` `<=` `==` `/=`
   - `compare a b` function generate `LT` `GT` `EQ` results
   - Bool values `True` `False` support `&&` `||` `not` operations
   - minus(-) is a operator you should pay attention to. `3 * (-4)` rather than `3 * -4`,it will report error
   - haskell is strong typed, `1 + "aaa"` don't make sense
- built-in functions
   -  `succ 7` returns 8
   -  `min` `max` `div`(like `/` operator) 
   -  function calls in pattern `fun param1 param2`. But we can use \`(backtick) to convert it to a infix funciton. For example <code>5 \`div\` 2<code>
   -  function is first class in haskell. we can define it just like variables except it has parameters
   -  `doubleX x = x + x` define a double function
   -  `if then` is an expression which return a value and `else` is mandatory. For example `biggerThanSeven x = if x > 7 then "bigger than 7" else "smaller than seven"`. You may check this url for [expression vs statement](https://stackoverflow.com/questions/4728073/what-is-the-difference-between-an-expression-and-a-statement-in-python)
   - Functions can't begin with uppercase letters
   
- lists operations
   - lists are a homogenous data structure
   - strings are list of chars
   - define a list `list = [1,2,3,4]`
   - `++` to put two list together
   - `:` to put an elem to a list `1:[2]` get `[1,2]` 
   - `!!` to get a elem by index `[1,2,3] !! 2` get `3`(index starts from 0)
   - support `>` `<` `>=` `<=` by comparing each elem in lexicographical order
   - functions 
      - `head` return first element 
      - `tail` sublist except first element
      - `init` sublist except last element
      - `last` return last element
      - ![image](http://s3.amazonaws.com/lyah/listmonster.png)
      - `length` 
      - `null` check a list if it's empty list
      - `reverse` a list
      - `take n list` take n elems from list. It's useful in a infinite list 
      - `drop n list` drop the first n elements
      - `maximum list` biggest elems (not only number only if they are comparable)
      - `minimum list` 
      - `sum list` sum a list of numbers
      - `product list` 
      - `elem` test a element is a member of list or not
    - Enumeration
       - `[1..10]` produce a list from 1 to 10 with step 1
       - `[10..1]` produce empty list because step is default 1
       - `[10,9..1]` you can use this way to set a step
       - `[1,4..10]` you get `[1,4,7,10]` the step is 3
       - `[1,3..]` without upper bound, we can create a infinite list.
    - Infinite List
       - `cycle list` cycle the elements into a infinite list
       - `repeat elem` like cycle with only one element in a list
       - use `take` to retrieve elements that you need.Don't try to display the result!
- List comprehension
    - we do this in math ![Set in math](http://s3.amazonaws.com/lyah/setnotation.png)
    - Haskell also give us the powerful ability to manipulate lists!
    - I wanna take 20 elements from a list generated by `[1,5..]` with each element mod 3 is 1 then double it, we can do this way using comprehension
    - `take 20 [x * 2 | x <- [1,5..], (mod x 3) == 1]`
    - Not only can we have multiple predictes but also we can draw elements from multiple lists.
    - `[x * y | x <- [1..4], y<-[5..9], x /= 3, y > 7]`
    - nested list examples `xxs = [[1,2],[3,4],[3,5]]`
    - `[[x | x<-xs, x /= 3] | xs <- xxs]`
    - What if we wanna flatten the list? Possible way is Recursion.
- Tuple
    - tuple is a bunch of element which can have different types and immuatable.
    - different size tuples are different types.
    - functions 
        - `fst tuple` take the first element of a tuple which only contains two elements
        - `snd tuple` take the second element 
        - `zip list1 list2` turn two lists into a list of tuples which consist of the corresponding element in each list 
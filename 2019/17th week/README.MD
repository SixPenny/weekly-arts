# Algorithm

### Description

Given an integer matrix, find the length of the longest increasing path.

From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).

Example 1:
```
Input: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
Output: 4 
Explanation: The longest increasing path is [1, 2, 6, 9].
```
Example 2:
```
Input: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
Output: 4 
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
```

### Solution

using DP

```java
class Solution {
  private int[][] mark;
  public int longestIncreasingPath(int[][] matrix) {
      if (matrix.length == 0) {
            return 0;
        }
        mark = new int[matrix.length][matrix[0].length];

        int max = 0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (mark[i][j] != 0) {
                    max = Math.max(max, mark[i][j]);
                } else {
                    max = Math.max(max, longestPathFrom(matrix, i, j));
                }
            }
        }
        return max;
    }

    private int longestPathFrom(int[][] matrix, int x, int y) {
        int pointMax = 1;
        int[][] positions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};

        for (int[] position : positions) {
            int a = x + position[0];
            int b = y + position[1];
            if (a < 0 || a >= matrix.length) {
                continue;
            }
            if (b < 0 || b >= matrix[0].length) {
                continue;
            }
            if (matrix[x][y] > matrix[a][b]) {
                if (mark[a][b] != 0) {
                    pointMax = Math.max(pointMax, mark[a][b] + 1);
                } else {
                    pointMax = Math.max(pointMax, longestPathFrom(matrix, a, b) + 1);
                }
            }
        }

        mark[x][y] = pointMax;
        return pointMax;
    }
}
```

# Review

[Why OO sucks](http://www.cs.otago.ac.nz/staffpriv/ok/Joe-Hates-OO.htm)

已故的Erlang 老爷子Joe Armstrong的一篇点评面向对象的文章，文中列举了OO的缺点：
1. 数据结构和函数不应绑定在一起
2. 任何事物都必须是对象
3. 在面向对象语言中，类型到处定义
4. 对象有私有状态

在我看来，任何技术都有suck 的地方，OO也不例外。不过Joe 列举的几个反对意见有待商榷。像4对象有私有状态，Haskell 虽然使用monad 形式隐藏了状态，但是并不是说隐藏就代表没有了，相反面向对象将状态封装在自己的作用域中减少扩散在我看来是更合适的做法


# Tips

阅读别人的代码+自己动手可以快速了解技术的原理。

本周写了点Android代码，通过看别人的代码发现，Android的布局其实就是类名，并且自己实现了业务通用的布局。这种学-用的循环真的是很不错。

# Share

## 抽象


### 概念

抽象是指缩减一个事物或一个含义的资讯含量来将其广义化的过程。

### 目的

1. 降低复杂度

抽象通过将一个事物中最本质的含义抽取出来，去掉了大量的信息。只保留下来核心信息，事物的复杂度大大降低。如果我们只看到了表面，事物包含的庞大信息将撑爆我们的记忆。

2. 概念化

我们将抽象出的事物通过命名来概念化，使得我们交流时只需通过名称就可以指代某一类事物，而不是具体的去描述信息。

3. 广义化

很多不同的事物，虽然其表面表现不同，但其核心本质是一样的。只通过表面无法将事物联系起来，抽象之后剩下了本质我们就可以很方面的将事物归类，一个方法的应用对象就由某个变成了某类。

### 实践注意事项

1. 关注本质，去掉无用信息

何为本质，何为无用，需要我们通过实践来把握。不同事物虽然包含的信息不同，我们分析事物的方法论是一致的。这是抽象的抽象，即如何界定本质？这个方法需要我们在实践中抽象出自己的方法论，才能不被纷繁事物晃花了眼。

2. 抽象层次

抽象层次包含两个概念：1）复杂系统需要分层，每层关注不同的粒度，合而为整体。2）在某一抽象层次上，抽象出的功能、概念应处于同一抽象层次，而不应混合不同抽象层次的功能、概念。

1） 分层

分层有几个目的：1⃣ 易于复用。 2⃣减少信息量。 3⃣ 概念化

1⃣ 易于复用    
事物粒度越小，则越易复用，粒度越大，则功能越完备。一颗螺钉可以用在很多需要衔接的地方，一台发动机就只能呆在车的前盖下。很显然，螺钉的可复用程度比发动机要高，这是因为螺钉和发动机不是一个抽象层次导致的。  
    
2⃣ 减少信息量

如果我们铁矿石、铜矿石等开始创造一台车需要多少知识呢？相对比如果我们使用车骨架、发动机、轮胎等现成组件需要多少知识呢？这两者包含的信息量根本不是一个数量级的。这就是分层的好处，车骨架、发动机等是建立在原始矿石的基础上的，但却比原始矿石高好几个层次，这样我们就不需要去了解底层是如何运作的，而只需要了解当前层次提供的功能就可以了。

3⃣ 概念化

当我们抽象出某一层次之后，就可以对它进行命名。命名也就是定义的过程，让我们更加理解当前层次的本质。我们日常交流时使用的词语很多是抽象产生出来的，譬如车，电脑，我们在交流时不会去解释车、电脑有哪些组成部分，如何运行，因为这是我们已经在创造这个词语时就已经定义好了。

2） 同一抽象层次

同一抽象层次在实践中是很重要的。编码时经常看到不同的人将不同抽象层次的代码放到一个接口中，这就将抽象的威力大大降低了。这就像谈论汽车组件时（轮胎，发动机，骨架、电池等）突然冒出来电池的蓄电原理一样，写代码虽然不像汽车有这么明确的边界，但我们需要努力明确自己某个类、包的边界，以及系统的边界。

3. 抽象角度

面对同一个大象，不同的人给出了不同的描述。即使是简单的一个房间，从不同的地方观察看到的景象也是不一样的。抽象也是如此，本质上抽象是在经过大量实践之后归纳出来的，可是不同的人有不同的经历，每个人对人生、世界的抽象也是不一样的，因此形成了不同的人生观、世界观。系统也如是，不同人从各自角度出发去认识。程序员看到一行行代码，产品看到一个个需求，测试看到一个个用例。因此体会不同人（同层次的，不同层次的）看到的，对我们自己的提升会有很大帮助。

角度没有好坏，但有高下之分。

4. 领域

领域是将内聚的功能放在一起，形成的范围的覆盖。领域是对外是高层的抽象，对内是同一本质的事物的聚合。领域内可以是分层的，领域也有粒度的划分，一个领域可以是几个领域更大范围的聚合，识别领域需要我们在抽象上的所有努力。


### 细节

细节可以说是和抽象相反的。抽象在于去掉大量信息，细节是让我们关注更多信息。我们平常一直训练的是弃掉细节的能力，在这里我也想强调一下看见细节的能力。

抽象不是万能的。如果只有抽象的认识，而没有具体事物的认识，那就堕入了空想主义的陷阱，也落入了人云亦云的窠臼。逻辑思维中有事实和观点之分，事实就是细节，观点则是在事实之上抽象出来的。只有观点而没有事实支撑，观点无法让人信服；只有事实而没有观点，事实就没有指导意义。

### 总结

抽象是一个很主观的概念，可以说我们一直以来接触到的世界就是一个抽象过了的世界，从这点来说，抽象有助于提高我们的逻辑能力，因为我们已经知道了我们意识中的世界并不是我们看到的，而是前人从他们的角度抽象出来的。

软件系统可以说变得越来越简单，也可以说变得越来越复杂。当你关注上层，会发现下层的复杂性已经全部隐藏起来了，不需要你去关注浏览器如何打开一个网页，渲染到屏幕上；当你关注底层，会发现底层是个无底洞，了解了html，css ，js，还需要了解 http -》tcp -》 os -》 CPU，如果你刨根问底的话，你需要去研究数学、化学、物理，才能明白一点为什么计算可以跑起来。

抽象是很重要的实践技能，不是写一篇文章就能立马掌握的，也不是银弹。我们只是需要让自己的武器库更丰富一点，面对复杂的世界多一点底气。
